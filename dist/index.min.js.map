{"version":3,"sources":["source-maps:///src/components/NumberTrio.vue","node-modules:///vue-runtime-helpers/dist/normalize-component.mjs","source-maps:///src/components/FormattedNumber.vue","source-maps:///src/components/bus.js","source-maps:///src/util.js","source-maps:///src/components/HasherItem.vue","source-maps:///src/components/FileInputDragNDrop.vue","source-maps:///src/md5-provider.js","source-maps:///src/components/MainContainer.vue","source-maps:///src/index.js"],"names":["script","name","props","value","type","String","required","[object Object]","Boolean","match","position","Number","count","padding","computed","this","parts","part1","part2","el","isLast","substring","length","normalizeComponent","template","style","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","options","render","staticRenderFns","_compiled","functional","_scopeId","hook","context","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","call","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","originalRender","renderWithStyleInjection","h","existing","beforeCreate","concat","__vue_script__","script$1","number","precision","default","isNegative","integer","decimal","toString","split","subDecimal","getTrios","methods","trios","offset","i","part","push","components","NumberTrio","__vue_component__","__vue_script__$1","bus","Vue","setImmediate","port1","port2","MessageChannel","queue","onmessage","callback","shift","postMessage","async","iterateReadableStream","stream","reader","getReader","done","read","iterateArrayBuffer","arrayBuffer","chunkSize","buffer","Uint8Array","index","chunk","subarray","iterateBlob2","blob","blobChunk","slice","size","isArrayBuffer","data","ArrayBuffer","isString","isBlob","Blob","secondsToFormattedString","seconds","date","Date","pad","str","padStart","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","bytesToSize","bytes","decimals","k","sizes","Math","floor","log","parseFloat","pow","toFixed","script$2","$on","onInputChanged","newInput","computing","time","progress","$forceUpdate","Promise","resolve","setTimeout","input","hasher","binarySupported","start","performance","now","loadingToMemoryTime","settings","hash","self","streamMode","console","readerChunkSize","_hashIterable","byteLength","iterable","curTime","totalRead","animation","newTime","fps","update","finalize","updateSupported","streamType","FormattedNumber","__vue_component__$1","__vue_script__$2","script$3","dropHover","file","$emit","event","fileElem","target","files","handleFileData","preventDefault","_","dataTransfer","dropEffect","document","querySelector","addEventListener","$el","contains","disableDragOverNonThisComponent","formatted-number","__vue_script__$3","Hasher","HasherBlueimp","TypeError","blueimpMD5","HasherCryptoJS","super","CryptoJS","algo","MD5","create","isView","lib","WordArray","_data","_consumize","HasherCbMD5","CbMD5","Buffer","from","digest","HasherJsMD5","JsMD5","hex","HasherNodeMD5","nodeMD5","HasherSparkMD5","SparkMD5","TextEncoder","encode","append","end","Object","assign","Blueimp","Browserify","Emn178","Node","Spark","defineProperty","get","values","script$4","HasherItem","__vue_component__$2","FileInputDragNDrop","__vue_component__$3","inputText","inputFile","inputBinary","storeInMemory","binaryLoading","readerChunkSizeMB","activeInputType","activeInputTypeAutoSwitcher","list","trunc","watch","updateInputBinary","item","$refs","items","compute","__vue_script__$4","createElement","MainContainer","$mount"],"mappings":"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","sourcesContent":["<template lang=\"pug\">\nspan.trio\n  span(v-if=\"part1\") {{part1}}\n  span.padded(v-if=\"part2\" :style=\"{letterSpacing: padding}\") {{part2}}\n</template>\n\n<script>\nexport default {\n  name: \"NumberTrio\",\n  props: {\n    value: {\n      type: String,\n      required: true,\n      validator(value) {\n        return Boolean(value.match(/^\\d+$/));\n      }\n    },\n    position: {\n      type: Number,\n      required: true,\n    },\n    count: {\n      type: Number,\n      required: true,\n    },\n    padding: { // letterSpacing value, e.g., \"5px\"\n      type: String\n    },\n  },\n  computed: {\n    part1() {\n      return this.parts.part1;\n    },\n    part2() {\n      return this.parts.part2;\n    },\n    parts() {\n      const el = this.value;\n      if (this.isLast) {\n        return {\n          part1: el,\n          part2: \"\"\n        };\n      } else {\n        return {\n          part1: el.substring(0, el.length - 1),\n          part2: el.substring(el.length - 1)\n        };\n      }\n    },\n    isLast() {\n      return this.position === this.count - 1;\n    }\n  }\n};\n</script>","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","<!--\n  It works OK only with integer numbers and partially with decimal numbers\n  (no support of `1.2e-34`, `Infinity`, `NaN`, for example)\n -->\n<template lang=\"pug\">\nspan.formatted-number\n  span.minus(v-if=\"isNegative\") -\n  span.integer\n    NumberTrio(\n        v-for=\"(integerTrio, index) of integerTrios\"\n        :value=\"integerTrio\"\n        :position=\"index\"\n        :count=\"integerTrios.length\"\n        :key=\"index\"\n        :padding=\"padding\"\n    )\n  span.point(v-if=\"decimalTrimmed\") .\n  span.decimal(v-if=\"decimalTrimmed\") {{decimalTrimmed}}\n</template>\n\n<script>\nimport NumberTrio from \"./NumberTrio.vue\";\n\nexport default {\n  name: \"FormattedNumber\",\n  props: {\n    number: {\n      type: Number,\n      required: true,\n    },\n    precision: { // Count of numbers after the point (the dot), if the integer part contains 1 digit\n      type: Number,\n      default: 2 // result for \"3\": \"1.123\", \"10.12\", \"100.1\", \"1000\"; for \"2\": \"1.01\", \"10\", \"100\";\n    },\n    padding: {   // letterSpacing value, e.g., \"5px\"\n      type: String,\n      default: null\n    }\n  },\n  computed: {\n    /** @returns {Boolean} */\n    isNegative() {\n      return this.parts.isNegative;\n    },\n    /** @returns {String} */\n    integer() {\n      return this.parts.integer;\n    },\n    /** @returns {String} */\n    decimal() {\n      return this.parts.decimal;\n    },\n    parts() {\n      const [integer, decimal] = this.number.toString().split(\".\");\n      const isNegative = this.number < 0;\n      return {\n        isNegative,\n        integer: isNegative ? integer.substring(1) : integer,\n        decimal\n      };\n    },\n    decimalTrimmed() {\n      const [integer, decimal] = [this.integer, this.decimal];\n      const precision = this.precision;\n\n      if (decimal) {\n        const subDecimal = decimal.substring(0, precision + 1 - integer.length);\n        // if contains only zeros\n        return subDecimal.match(/^0*$/) ? \"\" : subDecimal;\n      }\n      return null;\n    },\n    integerTrios() {\n      return this.getTrios(this.integer);\n    }\n  },\n  methods: {\n    getTrios(number) {\n      const trios = [];\n      const offset = ((number.length % 3) - 3) % 3;\n      for (let i = offset; i < number.length; i += 3) {\n        const part = number.substring(i, i + 3);\n        trios.push(part);\n      }\n      return trios;\n    }\n  },\n  components: {NumberTrio}\n};\n</script>","import Vue from \"vue\";\nexport const bus = new Vue();","export const setImmediate = /*#__PURE__*/ (function() {\n    const {port1, port2} = new MessageChannel();\n    const queue = [];\n\n    port1.onmessage = function() {\n        const callback = queue.shift();\n        callback();\n    };\n\n    return function(callback) {\n        port2.postMessage(null);\n        queue.push(callback);\n    };\n})();\n\n\nexport async function * iterateReadableStream(stream) {\n    const reader = stream.getReader();\n    while (true) {\n        const {done, /** @type {Uint8Array} */ value} = await reader.read();\n        if (done) {\n            break;\n        }\n        yield value;\n    }\n}\n\n// chunkSize is 65536, ReadableStream uses the same size.\n// There is no speed difference between using of different the chunk's sizes.\nexport function * iterateArrayBuffer(arrayBuffer, chunkSize = 65536) {\n    const buffer = new Uint8Array(arrayBuffer);\n    let index = 0;\n    while (true) {\n        const chunk = buffer.subarray(index, index + chunkSize);\n        if (!chunk.length) {\n            break;\n        }\n        yield chunk;\n        index += chunkSize;\n    }\n}\n\n// Note: `chunkSize` affects the execution speed\nexport function * iterateBlob1(blob, chunkSize = 2 * 1024 * 1024) {\n    let index = 0;\n    const reader = new FileReader();\n\n    while (true) {\n        const blobChunk = blob.slice(index, index + chunkSize);\n        if (!blobChunk.size) {break;}\n\n        yield read(blobChunk);\n        index += chunkSize;\n    }\n\n    async function read(blob) {\n        reader.readAsArrayBuffer(blob);\n        /** @type {ArrayBuffer} */\n        const result = await new Promise(resolve => {\n            reader.onload = () => resolve(reader.result);\n        });\n        return new Uint8Array(result);\n    }\n}\n\n// It works with the same speed in Chromium, but faster in Firefox\nexport function * iterateBlob2(blob, chunkSize = 2 * 1024 * 1024) {\n    let index = 0;\n    while (true) {\n        const blobChunk = blob.slice(index, index + chunkSize);\n        if (!blobChunk.size) {break;}\n\n        yield read(blobChunk);\n        index += chunkSize;\n    }\n\n    async function read(blob) {\n        return new Uint8Array(await blob.arrayBuffer());\n    }\n}\n\n\nexport function isArrayBuffer(data) {\n    return data instanceof ArrayBuffer;\n}\nexport function isBinary(data) {\n    return isArrayBuffer(data) || ArrayBuffer.isView(data);\n}\nexport function isString(data) {\n    return typeof data === \"string\" || data instanceof String;\n}\nexport function isBlob(data) { // is it Blob or File\n    return data instanceof Blob;\n}\n\n\nexport function secondsToFormattedString(seconds) {\n    const date = new Date(seconds * 1000);\n\n    // Adds zero padding\n    function pad(str) {\n        return str.toString().padStart(2, \"0\");\n    }\n\n    return date.getFullYear() + \".\" + pad(date.getMonth() + 1) + \".\" + pad(date.getDate()) + \" \" +\n        pad(date.getHours()) + \":\" + pad(date.getMinutes()) + \":\" + pad(date.getSeconds());\n}\n\n\nexport function bytesToSize(bytes, decimals = 2) {\n    if (bytes === 0) {\n        return \"0 B\";\n    }\n    const k = 1024;\n    decimals = decimals < 0 ? 0 : decimals;\n    const sizes = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return Number.parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + \" \" + sizes[i];\n}","<template>\n  <div class=\"hasher-item-component\"\n       :class=\"computing ? 'computing' : null\">\n    <div class=\"top\">\n      <div class=\"progress-line\"\n           :style=\"{width: progress+'%'}\"\n      ></div>\n      <div class=\"name\">{{ hasher.githubName }}</div>\n      <div class=\"compute-buttons\">\n        <button\n            @click=\"compute\"\n            :disabled=\"(!hasher.binarySupported && !inputIsString) ||\n                                     (input === null)\"\n            :title=\"(!hasher.binarySupported ? 'Does not support ArrayBuffer' : null) ||\n                                  (input === null ? 'No selected file' : 'Compute the hash without data splitting (the whole file will be loaded to memory)')\"\n        >Compute\n        </button>\n        <button\n            @click=\"streamCompute\"\n            :disabled=\"!hasher.updateSupported || streamMode === 'String' || settings.readerChunkSize < 1\"\n            :title=\"unsupportedStreamMethodMessage || streamMethodMessage\"\n        >Stream Compute\n        </button>\n      </div>\n\n    </div>\n    <div class=\"middle\"\n         :style=\"{opacity: newInput || !time ? '0.2' : '1'}\"\n    >\n      <div class=\"hash-times\">\n        <div class=\"hash-time\"\n             title=\"Hashing time\"\n        >\n          <span v-if=\"time\"><FormattedNumber :number=\"time\"/> ms</span>\n        </div>\n        <div class=\"file-loading-time\"\n             title=\"Loading to memory time\"\n        >\n          <span v-if=\"loadingToMemoryTime\"><FormattedNumber :number=\"loadingToMemoryTime\"/> ms</span>\n        </div>\n        <div class=\"total-hash-time\"\n             title=\"Total time\"\n        >\n          <div v-if=\"totalTime\"><FormattedNumber :number=\"totalTime\"/> ms</div>\n        </div>\n      </div>\n\n    </div>\n    <div class=\"bottom\">\n      <div class=\"hash\"\n           :style=\"{\n                   color: newInput ? '#ddd' : '#000',\n                   opacity: hash ? 1 : 0,\n                 }\"\n      >{{ hash }}</div>\n    </div>\n  </div>\n</template>\n\n<script>\nimport FormattedNumber from \"./FormattedNumber.vue\";\nimport {bus} from \"./bus.js\";\nimport * as Util from \"../util.js\";\n\nexport default {\n  created() {\n    bus.$on(\"input-changed\", this.onInputChanged);\n  },\n  props: [\"hasher\", \"input\", \"settings\"],\n  methods: {\n    onInputChanged() {\n      this.newInput = true;\n    },\n    async compute() {\n      this.computing = true;\n      this.time = 0;\n      this.progress = 0;\n      this.$forceUpdate();\n      await new Promise(resolve => setTimeout(resolve, 16));\n\n      let input;\n      if (Util.isString(this.input)) {\n        input = this.input;\n      } else {\n        if (!this.hasher.binarySupported) {\n          return;\n        }\n        if (Util.isBlob(this.input)) {\n          const start = performance.now();\n          input = await this.input.arrayBuffer();\n          this.loadingToMemoryTime = performance.now() - start;\n        } else {\n          input = this.input;\n          this.loadingToMemoryTime = this.settings.loadingToMemoryTime;\n        }\n        this.$forceUpdate();\n        await new Promise(resolve => setTimeout(resolve, 16));\n      }\n\n      const start = performance.now();\n      this.hash = this.hasher.hash(input);\n      this.progress = 100;\n      this.time = performance.now() - start;\n      this.newInput = false;\n\n      this.computing = false;\n    },\n    async streamCompute() {\n      this.computing = true;\n      this.progress = 0;\n      await new Promise(resolve => setTimeout(resolve, 16));\n\n      const self = this;\n      this.loadingToMemoryTime = null;\n\n      if (this.streamMode === \"FileReader\") {\n        console.log(this.settings.readerChunkSize);\n        await _hashIterable(Util.iterateBlob2(this.input, this.settings.readerChunkSize), this.input.size);\n      } else if (this.streamMode === \"ReadableStream\") {\n        await _hashIterable(Util.iterateReadableStream(this.input.stream()), this.input.size);\n      } else if (this.streamMode === \"ArrayBuffer\") {\n        await _hashIterable(Util.iterateArrayBuffer(this.input), this.input.byteLength);\n      }\n      this.newInput = false;\n      this.computing = false;\n\n      async function _hashIterable(iterable, length) {\n        const hasher = new self.hasher();\n        const start = performance.now();\n        let curTime = start;\n        let totalRead = 0;\n        const settings = self.settings;\n        self.progress = 0;\n        for await (const data of iterable) {\n          if (settings.animation) {\n            const newTime = performance.now();\n            if (newTime - curTime > (1000 / settings.fps)) {\n              curTime = newTime;\n              self.progress = (totalRead / length) * 100;\n              await new Promise(resolve => Util.setImmediate(resolve));\n            }\n            totalRead += data.length;\n          }\n\n          hasher.update(data);\n        }\n        self.progress = 100;\n\n        self.hash = hasher.finalize();\n        self.time = performance.now() - start;\n      }\n    }\n  },\n  data() {\n    return {\n      hash: \"\",\n      time: \"\",\n      progress: 0,\n      loadingToMemoryTime: null,\n      newInput: true,\n      computing: false,\n    }\n  },\n  computed: {\n    streamMethodMessage() {\n      if (this.streamMode === \"ArrayBuffer\") {\n        return \"Iterate ArrayBuffer chunks of the file loaded in the memory\";\n      }\n      if (this.streamMode === \"FileReader\") {\n        return \"Stream reading of the file via FileReader\";\n      }\n      if (this.streamMode === \"ReadableStream\") {\n        return \"Stream reading of the file via ReadableStream\";\n      }\n    },\n    unsupportedStreamMethodMessage() {\n      if (!this.hasher.updateSupported) {\n        return \"Does not support `update` method\";\n      }\n      if (this.streamMode === \"String\") {\n        return \"I see no sense to use progressive hashing for the text input\";\n      }\n    },\n    inputIsString() {\n      return Util.isString(this.input);\n    },\n    totalTime() {\n      if (this.loadingToMemoryTime && this.time) {\n        return (Number(this.time) + Number(this.loadingToMemoryTime)).toFixed(2);\n      } else {\n        return null;\n      }\n    },\n    streamMode() {\n      if (Util.isArrayBuffer(this.input)) {\n        return \"ArrayBuffer\"\n      } else if (Util.isBlob(this.input)) {\n        if (this.settings.streamType === \"FileReader\") {\n          return \"FileReader\"\n        }\n        if (this.settings.streamType === \"ReadableStream\") {\n          return \"ReadableStream\"\n        }\n      }\n      return \"String\";\n    }\n  },\n  components: {\n    FormattedNumber\n  }\n};\n</script>\n\n<style lang=\"scss\" scoped>\n\n.hasher-item-component {\n  width: 310px;\n  height: 200px;\n  border: 1px solid dimgray;\n  /*box-sizing: border-box;*/\n  margin: 4px 4px;\n\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n}\n\n.hasher-item-component .name {\n  padding: 6px 0;\n}\n\n.hasher-item-component > div {\n  width: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n}\n\n\n.hasher-item-component button {\n  user-select: none;\n}\n\n.hasher-item-component .hash {\n  display: flex;\n  justify-content: center;\n  padding-bottom: 4px;\n  padding-top: 4px;\n  border-top: 1px solid darkgrey;\n  width: 100%;\n\n}\n\n.hasher-item-component .progress-line {\n  background-color: var(--light-blue);\n  min-height: 4px;\n}\n\n\n.middle {\n  height: 100%;\n  position: relative;\n}\n\n.hash-times {\n  height: 100%;\n  width: 100%;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n}\n\n.hash-time {\n  font-size: 18px;\n}\n\n\n.file-loading-time {\n  position: absolute;\n  left: 0;\n  bottom: 0;\n  padding: 6px 18px;\n  opacity: 0.7;\n}\n\n.total-hash-time {\n  position: absolute;\n  right: 0;\n  bottom: 0;\n  padding: 6px 18px;\n  opacity: 0.8;\n}\n\n.hash {\n  height: 20px;\n}\n\n\n.computing .hash-time {\n  opacity: 0.3;\n}\n\n\n.hash-time {\n  text-shadow: var(--light-blue) 0 0 30px, var(--light-blue) 0 0 1px;\n  color: var(--dark-blue);\n}\n\n\n@media all and (min-width: 1280px) {\n  .hasher-item-component {\n    width: 280px;\n  }\n}\n\n</style>","<template>\n  <div class=\"file-input-drag-n-drop-component\"\n       v-bind:class=\"{'drop-hover': dropHover}\"\n       @drop=\"onFileDrop\"\n       @dragenter=\"onFileDragEnter\"\n       @dragleave=\"onFileDragLeave\"\n       @dragover=\"onFileDragOver\"\n  >\n    <label for=\"file-input\" style=\"width: 100%; height: 100%;\">\n      <div id=\"add-files-button\" v-if=\"!file\">\n        <slot>Select file</slot>\n      </div>\n      <input\n          id=\"file-input\" type=\"file\" accept=\"*/*\" style=\"display: none\"\n          @change=\"onFileInputChange\"\n      >\n      <div class=\"file-info\">\n        <div class=\"file-name\" v-if=\"file\" :title=\"file.name\">{{ file.name }}</div>\n        <div class=\"file-size\" v-if=\"file\">{{ bytesToSize(file.size) }}</div>\n        <div class=\"file-mtime\" v-if=\"file\">{{ secondsToFormattedString(file.lastModified / 1000) }}</div>\n      </div>\n\n    </label>\n  </div>\n</template>\n\n<script>\nimport FormattedNumber from \"./FormattedNumber.vue\";\nimport * as Util from \"../util.js\";\n\n\nexport default {\n  props: [\"file\"],\n  data() {\n    return {\n      dropHover: false\n    }\n  },\n  methods: {\n    secondsToFormattedString: Util.secondsToFormattedString,\n    bytesToSize: Util.bytesToSize,\n\n    async handleFileData(file) {\n      this.$emit(\"file-input-change\", file);\n    },\n\n    async onFileInputChange(event) {\n      const fileElem = event.target;\n      const file = fileElem.files[0];\n      await this.handleFileData(file);\n      fileElem.value = null;\n    },\n    async onFileDrop(event) {\n      event.preventDefault();\n      setTimeout(_ => this.dropHover = false, 50); // stupid blinking\n      const file = event.dataTransfer.files[0];\n      await this.handleFileData(file);\n    },\n    onFileDragEnter() {\n      setTimeout(_ => this.dropHover = true, 0);   // do after \"dragleave\"\n    },\n    onFileDragLeave() {\n      this.dropHover = false;\n    },\n    onFileDragOver(event) {\n      event.preventDefault();\n      event.dataTransfer.dropEffect = \"copy\";\n    },\n\n    disableDragOverNonThisComponent() {\n      document.querySelector(\"body\").addEventListener(\"dragover\", event => {\n        if (!this.$el.contains(event.target)) {\n          event.preventDefault();\n          event.dataTransfer.dropEffect = \"none\";\n        }\n      });\n    }\n  },\n  mounted() {\n    this.disableDragOverNonThisComponent();\n  },\n  components: {\n    \"formatted-number\": FormattedNumber\n  }\n}\n</script>\n<style lang=\"scss\" scoped>\n.file-input-drag-n-drop-component {\n  min-height: 6em;\n  transition: background-color 0.1s;\n  border: solid 1px var(--file-input-drag-n-drop-component-border);\n  box-sizing: border-box;\n\n  &.drop-hover { /*todo: rename - file-over */\n    background-color: var(--drop-file-over);\n    transition: background-color 0.1s;\n  }\n  &:hover {\n    background-color: var(--drop-hover);\n  }\n  &:active {\n    background-color: var(--drop-active);\n  }\n\n  label {\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n  }\n  .file-info {\n    max-width: 100%;\n    > * {\n      padding: 4px 12px;\n    }\n    .file-name {\n      text-overflow: ellipsis;\n      overflow: hidden;\n      white-space: nowrap;\n    }\n    .file-mtime {\n      opacity: 0.9;\n    }\n  }\n\n  #add-files-button {\n    font-size: 18px;\n  }\n}\n</style>","import {isString, isArrayBuffer} from \"./util.js\";\n\n/**\n * A normalised hasher\n * @abstract\n */\nclass Hasher {\n    static binarySupported = true;\n    static updateSupported = true;\n}\n\n//todo\n// https://stackoverflow.com/questions/1655769/fastest-md5-implementation-in-javascript\n// -\n// https://github.com/gorhill/yamd5.js/blob/master/yamd5.js\n// -\n// http://pajhome.org.uk/crypt/md5/md5.html\n// -\n// http://www.myersdaily.org/joseph/javascript/md5-text.html\n// http://www.myersdaily.org/joseph/javascript/md5.js\n// -\n// https://github.com/cotag/ts-md5\n\n\nclass HasherBlueimp extends Hasher {\n    static githubName = \"blueimp/JavaScript-MD5\";\n    static binarySupported = false;\n    static updateSupported = false;\n    static hash(data) {\n        if (!isString(data)) {\n            throw new TypeError(\"Data must be a string\");\n        }\n        return blueimpMD5(data);\n    }\n}\n\nclass HasherCryptoJS extends Hasher {\n    static githubName = \"brix/crypto-js\";\n    constructor() {\n        super();\n        this.hasher = CryptoJS.algo.MD5.create();\n    }\n\n    static _consumize(data) {\n        if (isString(data)) {\n            return data;\n        } else if (ArrayBuffer.isView(data) || isArrayBuffer(data)) {\n            return CryptoJS.lib.WordArray.create(data);\n        } else {\n            throw new TypeError(\"Data must be a string or a buffer\");\n        }\n    }\n\n    update(data) {\n        const _data = HasherCryptoJS._consumize(data);\n        this.hasher.update(_data);\n        return this;\n    }\n\n    finalize() {\n        return this.hasher.finalize().toString();\n    }\n\n    static hash(data) {\n        const _data = HasherCryptoJS._consumize(data);\n        return CryptoJS.MD5(_data).toString();\n    }\n}\n\nclass HasherCbMD5 extends Hasher {\n    static githubName = \"crypto-browserify/md5.js\";\n    constructor() {\n        super();\n        this.hasher = new CbMD5();\n    }\n\n    _consumize(data) {\n        if (isString(data)) {\n            return data;\n        } else if (ArrayBuffer.isView(data) || isArrayBuffer(data)) {\n            return Buffer.from(data);\n        } else {\n            throw new TypeError(\"Data must be a string or a buffer\");\n        }\n    }\n\n    update(data) {\n        const _data = this._consumize(data);\n        this.hasher.update(_data);\n        return this;\n    }\n\n    finalize() {\n        return this.hasher.digest(\"hex\");\n    }\n\n    static hash(data) {\n        return new HasherCbMD5().update(data).finalize();\n    }\n}\n\nclass HasherJsMD5 extends Hasher {\n    static githubName = \"emn178/js-md5\";\n    constructor() {\n        super();\n        this.hasher = JsMD5.create();\n    }\n\n    update(data) {\n        this.hasher.update(data);\n        return this;\n    }\n\n    finalize() {\n        return this.hasher.hex();\n    }\n\n    static hash(data) {\n        return JsMD5(data);\n    }\n}\n\nclass HasherNodeMD5 extends Hasher {\n    static githubName = \"pvorb/node-md5\";\n    static updateSupported = false;\n    static _consumize(data) {\n        if (isString(data)) {\n            return data;\n        } else if (ArrayBuffer.isView(data) || isArrayBuffer(data)) {\n            return Buffer.from(data);\n        } else {\n            throw new TypeError(\"Data must be a string or a buffer\");\n        }\n    }\n\n    static hash(data) {\n        return nodeMD5(HasherNodeMD5._consumize(data));\n    }\n}\n\nclass HasherSparkMD5 extends Hasher {\n    static githubName = \"satazor/js-spark-md5\";\n    constructor() {\n        super();\n        this.hasher = new SparkMD5.ArrayBuffer();\n    }\n\n    static _consumize(data) {\n        if (isString(data)) {\n            return new TextEncoder().encode(data);\n        }\n        return data;\n    }\n\n    update(data) {\n        const _data = HasherSparkMD5._consumize(data);\n        this.hasher.append(_data);\n        return this;\n    }\n\n    finalize() {\n        return this.hasher.end();\n    }\n\n    static hash(data) {\n        const _data = HasherSparkMD5._consumize(data);\n        return SparkMD5.ArrayBuffer.hash(_data);\n    }\n}\n\n\nconst MD5 = {};\nObject.assign(MD5, {\n    Blueimp: HasherBlueimp,\n    CryptoJS: HasherCryptoJS,\n    Browserify: HasherCbMD5,\n    Emn178: HasherJsMD5,\n    Node: HasherNodeMD5,\n    Spark: HasherSparkMD5,\n});\nObject.defineProperty(MD5, \"list\", { get: function() { return Object.values(this); } });\n\nexport default MD5; // globalThis.MD5 = MD5;","<template>\n  <div class=\"main-container-component\">\n    <div class=\"inputs\">\n      <div class=\"text-input\">\n        <div class=\"textarea-wrapper\"\n             :class=\"{'selected-input': activeInputType === 'text'}\">\n          <textarea placeholder=\"Type a text here\" v-model=\"inputText\"/>\n        </div>\n      </div>\n      <div class=\"file-group\">\n        <FileInputDragNDrop\n            :class=\"{'selected-input': activeInputType === 'file'}\"\n            ref=\"fileInputComponent\"\n            @file-input-change=\"onFileInputChange\"\n            :file=\"inputFile\"\n        ></FileInputDragNDrop>\n\n        <div class=\"settings\"\n             :class=\"{inactive: activeInputType !== 'file'}\">\n          <div class=\"store-in-memory\">\n            <label>\n              <input type=\"checkbox\"\n                     v-model=\"storeInMemory\"\n              > Store in memory {{ binaryLoading ? ' (loadings...)' : '' }}\n              <span title=\"loaded in\"\n                    v-if=\"loadingToMemoryTime && storeInMemory && inputBinary !== null\"\n              >(<FormattedNumber :number=\"loadingToMemoryTime\"/> ms)</span>\n            </label>\n          </div>\n\n          <div class=\"stream-type\">\n            <div :style=\"{opacity: storeInMemory ? 0.5 : 1}\">\n              <label><input type=\"radio\" name=\"streamType\" value=\"FileReader\"\n                            v-model=\"streamType\"\n              > FileReader</label>\n              <label><input type=\"radio\" name=\"streamType\" value=\"ReadableStream\"\n                            v-model=\"streamType\"\n              > ReadableStream</label>\n            </div>\n            <label title=\"Chunk size for progressive hashing, Megabytes\"\n                   :style=\"{opacity: streamType === 'ReadableStream' && !storeInMemory ? 0.5 : 1}\"\n            >Chunk size, MB\n              <input type=\"number\" min=\"0.1\" step=\"0.1\"\n                     v-model=\"readerChunkSizeMB\"\n                     :class=\"{invalid: readerChunkSize < 1}\"\n                     :title=\"readerChunkSize > 0 ? '' : 'Value must be greater than or equal to 1 byte'\"\n              ></label>\n          </div>\n          <div class=\"animation\">\n            <span class=\"checkbox\">\n              <label><input type=\"checkbox\" v-model=\"animation\"> Animation, </label>\n            </span>\n            <span class=\"fps\" :style=\"{opacity: animation ? 1 : 0.5}\">\n              <label>FPS <input type=\"number\" v-model=\"fps\"></label>\n            </span>\n          </div>\n        </div>\n      </div>\n    </div>\n\n    <div class=\"input-switch\">\n      <div class=\"switch-line\">\n        Input:\n        <label>\n          <input type=\"radio\" name=\"input\" value=\"text\" v-model=\"activeInputType\"> Text</label>\n        <label>\n          <input type=\"radio\" name=\"input\" value=\"file\" v-model=\"activeInputType\"> File</label>\n        <label\n            class=\"input-switch-checkbox\"\n            title=\"Switch the input type automatically based on the corresponding input change\">\n          <input type=\"checkbox\" v-model=\"activeInputTypeAutoSwitcher\"> Auto-Switch</label>\n      </div>\n      <div class=\"input-info\">Input size:\n        <span class=\"red\" v-if=\"activeInputType === 'file' && inputFile === null\">no file selected</span>\n        <span v-else><formatted-number :number=\"inputByteSize\"/> bytes</span>\n      </div>\n    </div>\n\n    <div class=\"items\">\n      <HasherItem\n          v-for=\"(hasher, index) of hashers\"\n          :hasher=\"hasher\"\n          :key=\"index\"\n          :input=\"input\"\n          :settings=\"{\n            fps,\n            animation,\n            readerChunkSize,\n            streamType,\n            loadingToMemoryTime\n          }\"\n          ref=\"items\"\n      ></HasherItem>\n    </div>\n\n    <div class=\"interface\">\n      <button @click=\"computeAll\">Compute all</button>\n      <!-- <button @click=\"clearInputData\">Clear input data</button>-->\n      <!-- <button @click=\"clearInputText\">Clear input text</button>-->\n    </div>\n  </div>\n</template>\n\n<script>\nimport HasherItem from \"./HasherItem.vue\";\nimport FileInputDragNDrop from \"./FileInputDragNDrop.vue\";\nimport FormattedNumber from \"./FormattedNumber.vue\";\nimport {bus} from \"./bus.js\";\nimport * as Util from \"../util.js\";\nimport MD5 from \"../md5-provider.js\";\n\nexport default {\n  name: \"MainContainer\",\n  components: {\n    HasherItem,\n    FileInputDragNDrop,\n    FormattedNumber\n  },\n  data() {\n    return {\n      inputText: \"\",\n      inputFile: null,\n      inputBinary: null,\n      storeInMemory: false,\n      binaryLoading: false,\n      loadingToMemoryTime: 0,\n      streamType: \"FileReader\",\n      animation: true,\n      fps: 25,\n      readerChunkSizeMB: 2,\n      activeInputType: \"text\",\n      activeInputTypeAutoSwitcher: true,\n    }\n  },\n  computed: {\n    inputByteSize() {\n      if (this.activeInputType === \"text\") {\n        return new TextEncoder().encode(this.inputText).byteLength;\n      }\n      if (this.activeInputType === \"file\" && this.inputFile) {\n        return this.inputFile.size/* || this.inputBinary.byteLength*/;\n      }\n      return 0;\n    },\n    hashers() {\n      return MD5.list;\n    },\n    input() {\n      if (this.activeInputType === \"file\") {\n        return this.inputBinary || this.inputFile;\n      } else if (this.activeInputType === \"text\") {\n        return this.inputText;\n      }\n    },\n    readerChunkSize() {\n      return Math.trunc(Number(this.readerChunkSizeMB) * 1024 * 1024);\n    },\n  },\n  watch: {\n    inputFile() {\n      if (this.activeInputTypeAutoSwitcher) {\n        this.activeInputType = \"file\";\n      }\n      bus.$emit(\"input-changed\");\n      this.updateInputBinary();\n    },\n    inputText() {\n      if (this.activeInputTypeAutoSwitcher) {\n        this.activeInputType = \"text\";\n      }\n      bus.$emit(\"input-changed\");\n    },\n    activeInputType() {\n      bus.$emit(\"input-changed\");\n    },\n    storeInMemory() {\n      this.updateInputBinary();\n    },\n  },\n  methods: {\n    async computeAll() {\n      bus.$emit(\"input-changed\"); // todo rename\n      for (const item of this.$refs.items) {\n        await item.compute();\n        await new Promise(resolve => Util.setImmediate(resolve));\n      }\n    },\n    clearInputData() {\n      this.inputFile = null;\n      this.inputBinary = null;\n    },\n    clearInputText() {\n      this.inputText = \"\";\n    },\n    async onFileInputChange(file) {\n      this.inputFile = file;\n    },\n    async updateInputBinary() {\n      // load file to the memory\n      if (this.storeInMemory && this.inputFile) {\n        this.loadingToMemoryTime = null;\n        this.binaryLoading = true;\n        const now = performance.now();\n        this.inputBinary = await this.inputFile.arrayBuffer();                                 // [1]\n        /* just to compare arrayBuffer() with FileReader */\n        // this.inputBinary = await (Util.iterateBlob1(this.inputFile, 1024**4).next()).value; // [2]\n        this.loadingToMemoryTime = performance.now() - now;\n        this.binaryLoading = false;\n      } else {\n        this.inputBinary = null;\n      }\n    }\n  }\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.main-container-component {\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n\n  .inputs {\n    width: 100%;\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    align-items: center;\n    justify-content: center;\n\n    > * {\n      margin: 4px 0px;\n    }\n\n    .selected-input {\n      border: solid 1px var(--selected-input-border);\n      box-sizing: border-box;\n      box-shadow: 0 0 10px var(--selected-input-box-shadow);\n    }\n\n    .text-input {\n      display: flex;\n      align-self: stretch;\n      box-sizing: border-box;\n      .textarea-wrapper {\n        border: solid 1px var(--textarea-wrapper-border);\n        box-sizing: border-box;\n        textarea {\n          width: 310px;\n          box-sizing: border-box;\n          display: block;\n          height: 100%;\n          border: 0;\n          outline: none;\n          min-height: 100px;\n          padding: 5px;\n          font-size: 17px;\n          &:focus::placeholder {\n            opacity: 0;\n            transition: opacity 0.25s ease;\n          }\n        }\n      }\n    }\n\n    .file-group {\n      box-sizing: border-box;\n      display: flex;\n      flex-direction: row;\n      flex-wrap: wrap;\n      justify-content: center;\n\n      > div {\n        width: 312px;\n      }\n\n      .settings {\n        width: 320px;\n        padding: 6px 8px;\n        box-sizing: border-box;\n\n        &.inactive {\n          opacity: 0.5;\n        }\n\n        > * {\n          margin: 6px;\n        }\n\n        input[type=\"number\"] {\n          max-width: 42px;\n\n          &.invalid {\n            border: 2px solid var(--red);\n            outline: none;\n            box-shadow: 0px 0px 1px 0px var(--red);\n          }\n        }\n\n        .stream-type input {\n          margin: 4px;\n        }\n      }\n    }\n  }\n\n  .input-switch {\n    padding: 6px;\n    margin-top: 12px;\n    margin-bottom: 24px;\n    > * {\n      padding: 0px 2px;\n    }\n    > div {\n      padding-bottom: 6px;\n    }\n\n    .input-switch-checkbox {\n      opacity: 0;\n      transition: opacity 0.4s ease;\n      &:hover {\n        opacity: 1;\n        transition: opacity 0.25s ease;\n      }\n    }\n  }\n\n  .red {\n    color: var(--red);\n  }\n\n  .items {\n    display: flex;\n    flex-direction: row;\n    flex-wrap: wrap;\n    justify-content: center;\n    align-items: center;\n  }\n\n  .interface {\n    display: flex;\n    justify-content: center;\n    margin: 4px;\n  }\n}\n\n/* scrollbar breaks it a bit for 961px - 974px */\n/* todo use grid */\n@media all and (min-width: 640px) and (max-width: 960px) {\n  .main-container-component .inputs .text-input .textarea-wrapper textarea {\n    width: 630px;\n  }\n}\n\n@media all and (min-width: 960px) {\n  .main-container-component .inputs > * {\n    margin-left: 4px;\n    margin-right: 4px;\n  }\n}\n</style>","import Vue from \"vue\";\nimport MainContainer from \"./components/MainContainer.vue\";\n\nnew Vue({\n    render: createElement => createElement(MainContainer),\n}).$mount(\"#app\");\n"]}