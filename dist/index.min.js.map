{"version":3,"sources":["source-maps:///src/store/input.js","source-maps:///src/store/file-settings.js","source-maps:///src/store/input-switch.js","source-maps:///src/util.js","source-maps:///src/store.js","source-maps:///src/components/NumberTrio.vue","node-modules:///vue-runtime-helpers/dist/normalize-component.mjs","source-maps:///src/components/FormattedNumber.vue","source-maps:///src/components/bus.js","source-maps:///src/components/HasherItem.vue","source-maps:///src/components/FileInputDragNDrop.vue","source-maps:///src/components/TextInput.vue","source-maps:///src/components/InputSwitch.vue","source-maps:///src/components/MemoryConsuming.vue","source-maps:///src/components/FileSettings.vue","source-maps:///src/components/MainContainer.vue","source-maps:///src/index.js"],"names":["state","text","file","binary","binaryLoading","loadingToMemoryTime","error","getters","[object Object]","TextEncoder","encode","byteLength","size","actions","commit","now","performance","arrayBuffer","console","dispatch","mutations","input","namespaced","storeInMemory","streamType","readerChunkSizeMB","animation","fps","useWorker","Math","trunc","Number","fileSettings","activeInputType","activeInputTypeAutoSwitcher","inputSwitch","setImmediate","port1","port2","MessageChannel","queue","onmessage","callback","shift","postMessage","push","async","iterateReadableStream","stream","reader","getReader","done","value","read","iterateArrayBuffer","chunkSize","buffer","Uint8Array","index","chunk","subarray","length","iterateBlob","blob","blobChunk","slice","isArrayBuffer","data","ArrayBuffer","isBinary","isView","isString","String","isBlob","Blob","secondsToFormattedString","seconds","date","Date","pad","str","toString","padStart","getFullYear","getMonth","getDate","getHours","getMinutes","getSeconds","bytesToSize","bytes","decimals","k","sizes","i","floor","log","parseFloat","pow","toFixed","Vue","use","Vuex","store","Store","modules","plugins","logger","subscribe","mutation","Util.isBinary","payload","Util.isArrayBuffer","type","payloadPreview","cellSize","Symbol","toStringTag","script","name","props","required","Boolean","match","position","count","padding","computed","this","parts","part1","part2","el","isLast","substring","normalizeComponent","template","style","scopeId","isFunctionalTemplate","moduleIdentifier","shadowMode","createInjector","createInjectorSSR","createInjectorShadow","options","render","staticRenderFns","_compiled","functional","_scopeId","hook","context","$vnode","ssrContext","parent","__VUE_SSR_CONTEXT__","call","_registeredComponents","add","_ssrRegister","$root","$options","shadowRoot","originalRender","renderWithStyleInjection","h","existing","beforeCreate","concat","__vue_script__","script$1","number","precision","default","isNegative","integer","decimal","split","subDecimal","getTrios","methods","trios","offset","part","components","NumberTrio","__vue_component__","__vue_script__$1","bus","script$2","$on","onInputChanged","$off","newInput","hasher","initialised","init","computing","time","progress","forceUpdate","binarySupported","start","_loadingToMemoryTime","inputIsString","hash","self","streamMode","_hashIterable","readerChunkSize","iterable","getInstance","curTime","totalRead","newTime","Promise","resolve","update","finalize","$forceUpdate","setTimeout","mapState","mapGetters","updateSupported","total","FormattedNumber","__vue_component__$1","__vue_script__$2","script$3","dropHover","mapActions","setFile","event","fileElem","target","files","handleFileData","preventDefault","_","dataTransfer","dropEffect","document","querySelector","addEventListener","$el","contains","disableDragOverNonThisComponent","__vue_script__$3","script$4","_text","setText","mapMutations","__vue_script__$4","script$5","inputText","inputFile","$store","textByteSize","fileByteSize","initBinary","clearBinary","watch","$emit","updateBinary","__vue_script__$5","script$6","memory","intervalId","over100","jsHeapSizeLimit","totalJSHeapSize","usedJSHeapSize","percent","isSupported","setInterval","clearInterval","__vue_script__$6","script$7","__vue_script__$7","script$8","hashers","globalThis","MD5","list","inputBinary","item","$refs","items","compute","TextInput","__vue_component__$4","FileInputDragNDrop","__vue_component__$3","HasherItem","__vue_component__$2","InputSwitch","__vue_component__$5","MemoryConsuming","__vue_component__$6","FileSettings","__vue_component__$7","__vue_script__$8","createElement","MainContainer","$mount"],"mappings":"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","sourcesContent":["const state = () => ({\n    /** @type {String} */\n    text: \"\",\n    /** @type {File} */\n    file: null,\n\n    /** @type {ArrayBuffer} */\n    binary: null,\n    /** @type {Boolean} */\n    binaryLoading: false,\n    /** @type {Number} */\n    loadingToMemoryTime: null,\n\n    /** @type {DOMException} */\n    error: null, // Loading file to memory error\n});\n\nconst getters = {\n    textByteSize(state, getters) {\n        return new TextEncoder().encode(state.text).byteLength;\n    },\n    fileByteSize(state, getters) {\n        return state.file ? state.file.size : null; // `state.binary.byteLength` for binary\n    },\n};\n\nconst actions = {\n    async setBinary({commit, state}, /** @type {File}*/ file) {\n        commit(\"_binaryLoading\", true);\n        if (state.error) {\n            commit(\"_clearError\");\n        }\n\n        try {\n            const now = performance.now();\n            const binary = await file.arrayBuffer();                           // [1]\n            /* just to compare arrayBuffer() with FileReader */\n            // binary = await (Util.iterateBlob1(file, 1024**4).next()).value; // [2]\n\n            commit(\"_binary\", binary);\n            commit(\"_loadingToMemoryTime\", performance.now() - now);\n        } catch (error) {\n            // When there is not enough memory space:\n            // DOMException:\n            // The requested file could not be read, typically due to permission problems\n            // that have occurred after a reference to a file was acquired.\n            console.error(error);\n            commit(\"_error\", error);  // error.name === NotReadableError\n        }\n        commit(\"_binaryLoading\", false);\n    },\n    async initBinary({dispatch, state}) {\n        await dispatch(\"setBinary\", state.file);\n    },\n    clearBinary({commit, state}) {\n        if (state.binary) {\n            commit(\"_binary\", null);\n            commit(\"_loadingToMemoryTime\", null);\n        }\n    },\n\n    setFile({commit, state}, file) {\n        if (state.error) {\n            commit(\"_clearError\");\n        }\n        commit(\"_file\", file);\n    },\n    clearFile({dispatch}) {\n        dispatch(\"setFile\", null);\n    },\n}\n\nconst mutations = {\n    setText(state, text) {\n        state.text = text;\n    },\n    clearText(state) {\n        state.text = \"\";\n    },\n\n    _file(state, file) {\n        state.file = file;\n    },\n    _binary(state, binary) {\n        state.binary = binary;\n    },\n    _binaryLoading(state, binaryLoading) {\n        state.binaryLoading = binaryLoading;\n    },\n    _loadingToMemoryTime(state, loadingToMemoryTime) {\n        state.loadingToMemoryTime = loadingToMemoryTime;\n    },\n\n    _error(state, error) {\n        state.error = error;\n    },\n    _clearError(state) {\n        state.error = null;\n    }\n};\n\n\nexport default {\n    namespaced: true,\n    state,\n    getters,\n    actions,\n    mutations\n}","const state = () => ({\n    storeInMemory: false,\n    streamType: \"FileReader\",\n    readerChunkSizeMB: 2,\n    animation: true,\n    fps: 25,\n    useWorker: true,\n});\n\nconst mutations = {\n    storeInMemory(state, storeInMemory) {\n        state.storeInMemory = storeInMemory;\n    },\n    streamType(state, streamType) {\n        state.streamType = streamType;\n    },\n    readerChunkSizeMB(state, readerChunkSizeMB) {\n        state.readerChunkSizeMB = readerChunkSizeMB;\n    },\n    animation(state, animation) {\n        state.animation = animation;\n    },\n    fps(state, fps) {\n        state.fps = fps;\n    },\n    useWorker(state, useWorker) {\n        state.useWorker = useWorker;\n    },\n};\n\nconst getters = {\n    readerChunkSize(state, getters) { // in bytes\n        return Math.trunc(Number(state.readerChunkSizeMB) * 1024 * 1024);\n    },\n};\n\nexport default {\n    namespaced: true,\n    state,\n    mutations,\n    getters\n}","const state = () => ({\n    activeInputType: \"text\",\n    activeInputTypeAutoSwitcher: true\n});\n\nconst mutations = {\n    activeInputType(state, activeInputType) {\n        state.activeInputType = activeInputType;\n    },\n    activeInputTypeAutoSwitcher(state, activeInputTypeAutoSwitcher) {\n        state.activeInputTypeAutoSwitcher = activeInputTypeAutoSwitcher;\n    }\n};\n\nexport default {\n    namespaced: true,\n    state,\n    mutations\n}","export const setImmediate = /*#__PURE__*/ (function() {\n    const {port1, port2} = new MessageChannel();\n    const queue = [];\n\n    port1.onmessage = function() {\n        const callback = queue.shift();\n        callback();\n    };\n\n    return function(callback) {\n        port2.postMessage(null);\n        queue.push(callback);\n    };\n})();\n\n\nexport async function * iterateReadableStream(stream) {\n    const reader = stream.getReader();\n    while (true) {\n        const {done, /** @type {Uint8Array} */ value} = await reader.read();\n        if (done) {\n            break;\n        }\n        yield value;\n    }\n}\n\n// chunkSize is 65536, ReadableStream uses the same size.\n// There is no speed difference between using of different the chunk's sizes.\nexport function * iterateArrayBuffer(arrayBuffer, chunkSize = 65536) {\n    const buffer = new Uint8Array(arrayBuffer);\n    let index = 0;\n    while (true) {\n        const chunk = buffer.subarray(index, index + chunkSize);\n        if (!chunk.length) {\n            break;\n        }\n        yield chunk;\n        index += chunkSize;\n    }\n}\n\n// Iterate Blob (or File)\n// Note: `chunkSize` affects the execution speed\n// It works with the same speed in Chromium, but a bit faster in Firefox (in comparison with `iterateBlob_v1`)\nexport function * iterateBlob(blob, chunkSize = 2 * 1024 * 1024) {\n    let index = 0;\n    while (true) {\n        const blobChunk = blob.slice(index, index + chunkSize);\n        if (!blobChunk.size) {break;}\n\n        yield read(blobChunk);\n        index += chunkSize;\n    }\n\n    async function read(blob) {\n        return new Uint8Array(await blob.arrayBuffer());\n    }\n}\n\nexport function * iterateBlob_v1(blob, chunkSize = 2 * 1024 * 1024) {\n    let index = 0;\n    const reader = new FileReader();\n\n    while (true) {\n        const blobChunk = blob.slice(index, index + chunkSize);\n        if (!blobChunk.size) {break;}\n\n        yield read(blobChunk);\n        index += chunkSize;\n    }\n\n    async function read(blob) {\n        reader.readAsArrayBuffer(blob);\n        /** @type {ArrayBuffer} */\n        const result = await new Promise(resolve => {\n            reader.onload = () => resolve(reader.result);\n        });\n        return new Uint8Array(result);\n    }\n}\n\nexport function isArrayBuffer(data) {\n    return data instanceof ArrayBuffer;\n}\nexport function isBinary(data) {\n    return isArrayBuffer(data) || ArrayBuffer.isView(data);\n}\nexport function isString(data) {\n    return typeof data === \"string\" || data instanceof String;\n}\nexport function isBlob(data) { // is it Blob or File\n    return data instanceof Blob;\n}\n\n\nexport function secondsToFormattedString(seconds) {\n    const date = new Date(seconds * 1000);\n\n    // Adds zero padding\n    function pad(str) {\n        return str.toString().padStart(2, \"0\");\n    }\n\n    return date.getFullYear() + \".\" + pad(date.getMonth() + 1) + \".\" + pad(date.getDate()) + \" \" +\n        pad(date.getHours()) + \":\" + pad(date.getMinutes()) + \":\" + pad(date.getSeconds());\n}\n\n\nexport function bytesToSize(bytes, decimals = 2) {\n    if (bytes === 0) {\n        return \"0 B\";\n    }\n    const k = 1024;\n    decimals = decimals < 0 ? 0 : decimals;\n    const sizes = [\"B\", \"KB\", \"MB\", \"GB\", \"TB\", \"PB\", \"EB\", \"ZB\", \"YB\"];\n\n    const i = Math.floor(Math.log(bytes) / Math.log(k));\n    return Number.parseFloat((bytes / Math.pow(k, i)).toFixed(decimals)) + \" \" + sizes[i];\n}","import Vue from \"vue\";\nimport Vuex from \"vuex\";\n\nimport input from \"./store/input.js\";\nimport fileSettings from \"./store/file-settings.js\";\nimport inputSwitch from \"./store/input-switch.js\";\nimport * as Util from \"./util.js\";\n\n\nVue.use(Vuex);\n\nexport default new Vuex.Store({\n    modules: {\n        input,\n        [\"file-settings\"]: fileSettings,\n        [\"input-switch\"]: inputSwitch\n    },\n    plugins: [logger]\n});\n\nfunction logger(store) {\n    store.subscribe((mutation/*, state*/) => {\n        // to prevent the large memory leak\n        if (Util.isBinary(mutation.payload)) {\n            const binary = mutation.payload;\n\n            if (Util.isArrayBuffer(binary)) {\n                console.log({\n                    type: mutation.type,\n                    payload: \"ArrayBuffer(\" + binary.byteLength + \")\",\n                    payloadPreview: new Uint8Array(binary).slice(0, 1024).buffer\n                });\n            } else {\n                const cellSize = binary.slice(0, 1).byteLength || 1; // if `length === 0`\n                console.log({\n                    type: mutation.type,\n                    payload: binary[Symbol.toStringTag] + \"(\" + binary.length + \")\",\n                    payloadPreview: binary.slice(0, 1024 / cellSize)\n                });\n            }\n        } else {\n            console.log(mutation);\n        }\n    });\n}","<template lang=\"pug\">\nspan.number-trio-component\n  span(v-if=\"part1\") {{part1}}\n  span.padded(v-if=\"part2\" :style=\"{letterSpacing: padding}\") {{part2}}\n</template>\n\n<script>\nexport default {\n  name: \"NumberTrio\",\n  props: {\n    value: {\n      type: String,\n      required: true,\n      validator(value) {\n        return Boolean(value.match(/^\\d+$/));\n      }\n    },\n    position: {\n      type: Number,\n      required: true,\n    },\n    count: {\n      type: Number,\n      required: true,\n    },\n    padding: { // letterSpacing value, e.g., \"5px\"\n      type: String\n    },\n  },\n  computed: {\n    part1() {\n      return this.parts.part1;\n    },\n    part2() {\n      return this.parts.part2;\n    },\n    parts() {\n      const el = this.value;\n      if (this.isLast) {\n        return {\n          part1: el,\n          part2: \"\"\n        };\n      } else {\n        return {\n          part1: el.substring(0, el.length - 1),\n          part2: el.substring(el.length - 1)\n        };\n      }\n    },\n    isLast() {\n      return this.position === this.count - 1;\n    }\n  }\n};\n</script>","function normalizeComponent(template, style, script, scopeId, isFunctionalTemplate, moduleIdentifier /* server only */, shadowMode, createInjector, createInjectorSSR, createInjectorShadow) {\r\n    if (typeof shadowMode !== 'boolean') {\r\n        createInjectorSSR = createInjector;\r\n        createInjector = shadowMode;\r\n        shadowMode = false;\r\n    }\r\n    // Vue.extend constructor export interop.\r\n    const options = typeof script === 'function' ? script.options : script;\r\n    // render functions\r\n    if (template && template.render) {\r\n        options.render = template.render;\r\n        options.staticRenderFns = template.staticRenderFns;\r\n        options._compiled = true;\r\n        // functional template\r\n        if (isFunctionalTemplate) {\r\n            options.functional = true;\r\n        }\r\n    }\r\n    // scopedId\r\n    if (scopeId) {\r\n        options._scopeId = scopeId;\r\n    }\r\n    let hook;\r\n    if (moduleIdentifier) {\r\n        // server build\r\n        hook = function (context) {\r\n            // 2.3 injection\r\n            context =\r\n                context || // cached call\r\n                    (this.$vnode && this.$vnode.ssrContext) || // stateful\r\n                    (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext); // functional\r\n            // 2.2 with runInNewContext: true\r\n            if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\r\n                context = __VUE_SSR_CONTEXT__;\r\n            }\r\n            // inject component styles\r\n            if (style) {\r\n                style.call(this, createInjectorSSR(context));\r\n            }\r\n            // register component module identifier for async chunk inference\r\n            if (context && context._registeredComponents) {\r\n                context._registeredComponents.add(moduleIdentifier);\r\n            }\r\n        };\r\n        // used by ssr in case component is cached and beforeCreate\r\n        // never gets called\r\n        options._ssrRegister = hook;\r\n    }\r\n    else if (style) {\r\n        hook = shadowMode\r\n            ? function (context) {\r\n                style.call(this, createInjectorShadow(context, this.$root.$options.shadowRoot));\r\n            }\r\n            : function (context) {\r\n                style.call(this, createInjector(context));\r\n            };\r\n    }\r\n    if (hook) {\r\n        if (options.functional) {\r\n            // register for functional component in vue file\r\n            const originalRender = options.render;\r\n            options.render = function renderWithStyleInjection(h, context) {\r\n                hook.call(context);\r\n                return originalRender(h, context);\r\n            };\r\n        }\r\n        else {\r\n            // inject component registration as beforeCreate hook\r\n            const existing = options.beforeCreate;\r\n            options.beforeCreate = existing ? [].concat(existing, hook) : [hook];\r\n        }\r\n    }\r\n    return script;\r\n}\n\nexport default normalizeComponent;\n//# sourceMappingURL=normalize-component.mjs.map\n","<!--\n  It works OK only with integer numbers and partially with decimal numbers\n  (no support of `1.2e-34`, `Infinity`, `NaN`, for example)\n\n  To style it pass `padding` property\n  or use:\n  ... ::v-deep .formatted-number .trio > .padded {\n    letter-spacing: 4px;\n  }\n -->\n<template lang=\"pug\">\nspan.formatted-number-component\n  span.minus(v-if=\"isNegative\") -\n  span.integer\n    NumberTrio(\n        v-for=\"(integerTrio, index) of integerTrios\"\n        :value=\"integerTrio\"\n        :position=\"index\"\n        :count=\"integerTrios.length\"\n        :key=\"index\"\n        :padding=\"padding\"\n    )\n  span.point(v-if=\"decimalTrimmed\") .\n  span.decimal(v-if=\"decimalTrimmed\") {{decimalTrimmed}}\n</template>\n\n<script>\nimport NumberTrio from \"./NumberTrio.vue\";\n\nexport default {\n  name: \"FormattedNumber\",\n  props: {\n    number: {\n      type: Number,\n      required: true,\n    },\n    precision: { // Count of numbers after the point (the dot), if the integer part contains 1 digit\n      type: Number,\n      default: 2 // result for \"3\": \"1.123\", \"10.12\", \"100.1\", \"1000\"; for \"2\": \"1.01\", \"10\", \"100\";\n    },\n    padding: {   // letterSpacing value, e.g., \"5px\"\n      type: String,\n      default: null\n    }\n  },\n  computed: {\n    /** @returns {Boolean} */\n    isNegative() {\n      return this.parts.isNegative;\n    },\n    /** @returns {String} */\n    integer() {\n      return this.parts.integer;\n    },\n    /** @returns {String} */\n    decimal() {\n      return this.parts.decimal;\n    },\n    parts() {\n      const [integer, decimal] = this.number.toString().split(\".\");\n      const isNegative = this.number < 0;\n      return {\n        isNegative,\n        integer: isNegative ? integer.substring(1) : integer,\n        decimal\n      };\n    },\n    decimalTrimmed() {\n      const [integer, decimal] = [this.integer, this.decimal];\n      const precision = this.precision;\n\n      if (decimal) {\n        const subDecimal = decimal.substring(0, precision + 1 - integer.length);\n        // if contains only zeros\n        return subDecimal.match(/^0*$/) ? \"\" : subDecimal;\n      }\n      return null;\n    },\n    integerTrios() {\n      return this.getTrios(this.integer);\n    }\n  },\n  methods: {\n    getTrios(number) {\n      const trios = [];\n      const offset = ((number.length % 3) - 3) % 3;\n      for (let i = offset; i < number.length; i += 3) {\n        const part = number.substring(i, i + 3);\n        trios.push(part);\n      }\n      return trios;\n    }\n  },\n  components: {NumberTrio}\n};\n</script>","import Vue from \"vue\";\nexport const bus = new Vue();","<template lang=\"pug\">\ndiv.hasher-item-component(:class=\"computing ? 'computing' : null\")\n\n  div.top\n    div.progress-line(:style=\"{width: progress+'%'}\")\n    div.name\n      | {{ hasher.githubName }}\n    div.compute-buttons\n      button(\n          @click=\"compute\"\n          :disabled=\"(!hasher.binarySupported && !inputIsString) || (input === null)\"\n          :title=`(!hasher.binarySupported ? 'Does not support ArrayBuffer' : null) ||\n                  (input === null ?\n                     'No selected file' :\n                     'Compute the hash without data splitting (the whole file will be loaded to memory)')`)\n        | Compute\n      button(\n          @click=\"streamCompute\"\n          :disabled=\"!hasher.updateSupported || streamMode === 'String' || readerChunkSize < 1\"\n          :title=\"unsupportedStreamMethodMessage || streamMethodMessage\")\n        | Stream Compute\n\n  div.middle(:style=\"{opacity: newInput || !time ? '0.2' : '1'}\")\n    div.hash-times\n      div.hash-time(title=\"Hashing time\")\n        span(v-if=\"time\")\n          FormattedNumber(:number=\"time\")\n          |\n          | ms\n      div.file-loading-time(title=\"Loading to memory time\")\n        span(v-if=\"loadingToMemoryTime\")\n          FormattedNumber(:number=\"loadingToMemoryTime\")\n          |\n          | ms\n      div.total-hash-time(title=\"Total time\")\n        div(v-if=\"totalTime\")\n          FormattedNumber(:number=\"totalTime\")\n          |\n          | ms\n\n  div.bottom\n    div.hash(\n        :style=`{\n          color: newInput ? '#ddd' : '#000',\n          opacity: hash ? 1 : 0,\n        }`)\n      | {{ hash }}\n</template>\n\n<script>\nimport FormattedNumber from \"./FormattedNumber.vue\";\nimport {bus} from \"./bus.js\";\nimport * as Util from \"../util.js\";\nimport {mapState, mapGetters} from \"vuex\";\n\nexport default {\n  created() {\n    bus.$on(\"input-changed\", this.onInputChanged);\n  },\n  beforeDestroy() {\n    bus.$off(\"input-changed\", this.onInputChanged);\n  },\n  props: [\"hasher\", \"input\"],\n  methods: {\n    onInputChanged() {\n      this.newInput = true;\n    },\n    async compute() {\n      if (!this.hasher.initialised) {\n        await this.hasher.init(); // if worker?\n      }\n\n      this.computing = true;\n      this.time = 0;\n      this.progress = 0;\n      await this.forceUpdate();\n\n      let input;\n      if (Util.isString(this.input)) {\n        input = this.input;\n      } else {\n        if (!this.hasher.binarySupported) {\n          return;\n        }\n        if (Util.isBlob(this.input)) {\n          const start = performance.now();\n          input = await this.input.arrayBuffer();\n          this.loadingToMemoryTime = performance.now() - start;\n        } else {\n          input = this.input;\n          this.loadingToMemoryTime = this._loadingToMemoryTime;\n        }\n        await this.forceUpdate();\n      }\n\n      const useWorker = this.useWorker && !this.inputIsString;\n      const start = performance.now();\n      this.hash = await this.hasher.hash(input, useWorker);\n      this.time = performance.now() - start;\n      this.progress = 100;\n      this.newInput = false;\n\n      this.computing = false;\n    },\n    async streamCompute() {\n      if (!this.hasher.initialised) {\n        await this.hasher.init();\n      }\n\n      this.computing = true;\n      this.progress = 0;\n      await this.forceUpdate();\n\n      const self = this;\n      this.loadingToMemoryTime = null;\n\n      if (this.streamMode === \"FileReader\") {\n        await _hashIterable(Util.iterateBlob(this.input, this.readerChunkSize), this.input.size);\n      } else if (this.streamMode === \"ReadableStream\") {\n        await _hashIterable(Util.iterateReadableStream(this.input.stream()), this.input.size);\n      } else if (this.streamMode === \"ArrayBuffer\") { // if stored in memory\n        await _hashIterable(Util.iterateArrayBuffer(this.input), this.input.byteLength);\n      }\n      this.newInput = false;\n      this.computing = false;\n\n      /** @typedef {Iterable<Uint8Array>|Generator<Uint8Array>|AsyncGenerator<Uint8Array>} IterableU8A */\n      async function _hashIterable(/**@type {IterableU8A}*/ iterable, length) {\n        const hasher = self.hasher.getInstance();\n        const start = performance.now();\n        let curTime = start;\n        let totalRead = 0;\n        self.progress = 0;\n        for await (const data of iterable) {\n          if (self.animation) {\n            const newTime = performance.now();\n            if (newTime - curTime > (1000 / self.fps)) {\n              curTime = newTime;\n              self.progress = (totalRead / length) * 100;\n              await new Promise(resolve => Util.setImmediate(resolve));\n            }\n            totalRead += data.length;\n          }\n\n          hasher.update(data);\n        }\n        self.progress = 100;\n\n        self.hash = hasher.finalize();\n        self.time = performance.now() - start;\n      }\n    },\n    async forceUpdate() {\n      this.$forceUpdate();\n      await new Promise(resolve => setTimeout(resolve, 16));\n    },\n  },\n  data() {\n    return {\n      hash: \"\",\n      time: \"\",\n      progress: 0,\n      loadingToMemoryTime: null,\n      newInput: true,\n      computing: false,\n    }\n  },\n  computed: {\n    ...mapState(\"file-settings\", {\n      animation: state => state.animation,\n      fps: state => state.fps,\n      streamType: state => state.streamType,\n      useWorker: state => state.useWorker,\n    }),\n    ...mapGetters(\"file-settings\", [\"readerChunkSize\"]),\n\n    ...mapState(\"input\", {\n      _loadingToMemoryTime: state => state.loadingToMemoryTime,\n    }),\n\n    streamMethodMessage() {\n      if (this.streamMode === \"ArrayBuffer\") {\n        return \"Iterate ArrayBuffer chunks of the file loaded in the memory\";\n      }\n      if (this.streamMode === \"FileReader\") {\n        return \"Stream reading of the file via FileReader\";\n      }\n      if (this.streamMode === \"ReadableStream\") {\n        return \"Stream reading of the file via ReadableStream\";\n      }\n    },\n    unsupportedStreamMethodMessage() {\n      if (!this.hasher.updateSupported) {\n        return \"Does not support `update` method\";\n      }\n      if (this.streamMode === \"String\") {\n        return \"I see no sense to use progressive hashing for the text input\";\n      }\n    },\n    inputIsString() {\n      return Util.isString(this.input);\n    },\n    totalTime() {\n      if (this.loadingToMemoryTime && this.time) {\n        const total = Number(this.time) + Number(this.loadingToMemoryTime);\n        return Number(total.toFixed(2));\n      } else {\n        return null;\n      }\n    },\n    streamMode() {\n      if (Util.isArrayBuffer(this.input)) {\n        return \"ArrayBuffer\"\n      } else if (Util.isBlob(this.input)) {\n        if (this.streamType === \"FileReader\") {\n          return \"FileReader\"\n        }\n        if (this.streamType === \"ReadableStream\") {\n          return \"ReadableStream\"\n        }\n      }\n      return \"String\";\n    }\n  },\n  components: {\n    FormattedNumber\n  }\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.hasher-item-component {\n  height: 200px;\n  border: 1px solid dimgray;\n  box-sizing: border-box;\n\n  display: flex;\n  flex-direction: column;\n  justify-content: space-between;\n\n  > div {\n    width: 100%;\n    display: flex;\n    flex-direction: column;\n    align-items: center;\n  }\n\n  .top {\n    .progress-line {\n      background-color: var(--light-blue);\n      min-height: 4px;\n    }\n    .name {\n      padding: 6px 0;\n    }\n    .compute-buttons {\n      button {\n        user-select: none;\n      }\n    }\n  }\n\n  .middle {\n    height: 100%;\n    position: relative;\n    .hash-times {\n      height: 100%;\n      width: 100%;\n      display: flex;\n      justify-content: center;\n      align-items: center;\n      flex-direction: column;\n      .hash-time {\n        font-size: 18px;\n        text-shadow: var(--light-blue) 0 0 30px, var(--light-blue) 0 0 1px;\n        color: var(--dark-blue);\n        &.computing {\n          opacity: 0.3;\n        }\n      }\n      .file-loading-time {\n        position: absolute;\n        left: 0;\n        bottom: 0;\n        padding: 6px 18px;\n        opacity: 0.7;\n      }\n      .total-hash-time {\n        position: absolute;\n        right: 0;\n        bottom: 0;\n        padding: 6px 18px;\n        opacity: 0.8;\n      }\n    }\n  }\n\n  .bottom {\n    .hash {\n      display: flex;\n      justify-content: center;\n      padding-bottom: 4px;\n      padding-top: 4px;\n      border-top: 1px solid darkgrey;\n      width: 100%;\n      height: 20px;\n    }\n  }\n}\n</style>","<template lang=\"pug\">\ndiv.file-input-drag-n-drop-component(\n    v-bind:class=\"{'drop-hover': dropHover}\"\n    @drop=\"onFileDrop\"\n    @dragenter=\"onFileDragEnter\"\n    @dragleave=\"onFileDragLeave\"\n    @dragover=\"onFileDragOver\")\n  label(for=\"file-input\")\n    div#add-files-button(v-if=\"!file\")\n      slot\n        | Select file\n    input(id=\"file-input\" type=\"file\" accept=\"*/*\" style=\"display: none\"\n          @change=\"onFileInputChange\")\n    div.file-info\n      div.file-name(v-if=\"file\" :title=\"file.name\")\n        | {{ file.name }}\n      div.file-size(v-if=\"file\")\n        | {{ bytesToSize(file.size) }}\n      div.file-mtime(v-if=\"file\")\n        | {{ secondsToFormattedString(file.lastModified / 1000) }}\n</template>\n\n<script>\nimport * as Util from \"../util.js\";\nimport {mapActions, mapState} from \"vuex\";\n\nexport default {\n  data() {\n    return {\n      dropHover: false\n    }\n  },\n  computed: {\n    ...mapState(\"input\", {\n      file: state => state.file\n    })\n  },\n  methods: {\n    ...mapActions(\"input\", [\"setFile\"]),\n\n    secondsToFormattedString: Util.secondsToFormattedString,\n    bytesToSize: Util.bytesToSize,\n\n    async handleFileData(file) {\n      this.setFile(file);\n    },\n\n    async onFileInputChange(event) {\n      const fileElem = event.target;\n      const file = fileElem.files[0];\n      await this.handleFileData(file);\n      fileElem.value = null;\n    },\n    async onFileDrop(event) {\n      event.preventDefault();\n      setTimeout(_ => this.dropHover = false, 50); // stupid blinking\n      const file = event.dataTransfer.files[0];\n      await this.handleFileData(file);\n    },\n    onFileDragEnter() {\n      setTimeout(_ => this.dropHover = true, 0);   // do after \"dragleave\"\n    },\n    onFileDragLeave() {\n      this.dropHover = false;\n    },\n    onFileDragOver(event) {\n      event.preventDefault();\n      event.dataTransfer.dropEffect = \"copy\";\n    },\n\n    disableDragOverNonThisComponent() {\n      document.querySelector(\"body\").addEventListener(\"dragover\", event => {\n        if (!this.$el.contains(/** @type {DragEvent}*/ event.target)) {\n          event.preventDefault();\n          event.dataTransfer.dropEffect = \"none\";\n        }\n      });\n    }\n  },\n  mounted() {\n    this.disableDragOverNonThisComponent();\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.file-input-drag-n-drop-component {\n  transition: background-color 0.1s;\n  border: solid 1px var(--file-input-drag-n-drop-component-border);\n  box-sizing: border-box;\n\n  &.drop-hover { /*todo: rename - file-over */\n    background-color: var(--drop-file-over);\n    transition: background-color 0.1s;\n  }\n  &:hover {\n    background-color: var(--drop-hover);\n  }\n  &:active {\n    background-color: var(--drop-active);\n  }\n\n  label {\n    width: 100%;\n    height: 100%;\n    display: flex;\n    flex-direction: column;\n    justify-content: center;\n    align-items: center;\n  }\n  .file-info {\n    max-width: 100%;\n    > * {\n      padding: 4px 12px;\n    }\n    .file-name {\n      text-overflow: ellipsis;\n      overflow: hidden;\n      white-space: nowrap;\n    }\n    .file-mtime {\n      opacity: 0.9;\n    }\n  }\n\n  #add-files-button {\n    font-size: 18px;\n  }\n}\n</style>","<template lang=\"pug\">\ndiv.text-input-component\n  label\n    textarea(placeholder=\"Type a text here\" v-model=\"text\")\n</template>\n\n<script>\nimport {mapMutations, mapState} from \"vuex\";\n\nexport default {\n  name: \"TextInput\",\n  computed: {\n    ...mapState(\"input\", {\n      _text: state => state.text,\n    }),\n    text: {\n      get() {\n        return this._text;\n      },\n      set(value) {\n        this.setText(value);\n      }\n    }\n  },\n  methods: {\n    ...mapMutations(\"input\", [\"setText\"])\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.text-input-component {\n  border: solid 1px var(--textarea-wrapper-border);\n  box-sizing: border-box;\n  width: 100%;\n  textarea {\n    width: 100%;\n    box-sizing: border-box;\n    height: calc(100% - 1px); // firefox bug\n    border: 0;\n    outline: none;\n    padding: 5px;\n    font-size: 17px;\n    &:focus::placeholder {\n      opacity: 0;\n      transition: opacity 0.25s ease;\n    }\n  }\n}\n</style>","<template lang=\"pug\">\ndiv.input-switch-component\n  div.switch-line\n    | Input:\n    label\n      input(type=\"radio\" name=\"input\" value=\"text\" v-model=\"activeInputType\")\n      | Text\n    label\n      input(type=\"radio\" name=\"input\" value=\"file\" v-model=\"activeInputType\")\n      | File\n    label(\n      class=\"input-switch-checkbox\"\n      title=\"Switch the input type automatically based on the corresponding input change\")\n      input(type=\"checkbox\" v-model=\"activeInputTypeAutoSwitcher\")\n      | Auto-Switch\n  div.input-info\n    | Input size:\n    |\n    span(class=\"red\" v-if=\"activeInputType === 'file' && inputFile === null\")\n      | no file selected\n    span(v-else)\n      FormattedNumber(:number=\"inputByteSize\")\n      |\n      | bytes\n</template>\n\n<script>\nimport {bus} from \"./bus.js\";\nimport FormattedNumber from \"./FormattedNumber.vue\";\nimport {mapActions, mapGetters, mapState} from \"vuex\";\n\nexport default {\n  name: \"InputSwitch\",\n  computed: {\n    ...mapState(\"file-settings\", {\n      storeInMemory: state => state.storeInMemory,\n    }),\n\n    ...mapState(\"input\", {\n      inputText: state => state.text,\n      inputFile: state => state.file,\n    }),\n    ...mapGetters(\"input\", [\"textByteSize\", \"fileByteSize\"]),\n\n    activeInputType: {\n      get() { return this.$store.state[\"input-switch\"].activeInputType; },\n      set(value) { this.$store.commit(\"input-switch/activeInputType\", value); }\n    },\n    activeInputTypeAutoSwitcher: {\n      get() { return this.$store.state[\"input-switch\"].activeInputTypeAutoSwitcher; },\n      set(value) { this.$store.commit(\"input-switch/activeInputTypeAutoSwitcher\", value); }\n    },\n\n    inputByteSize() {\n      if (this.activeInputType === \"text\") {\n        return this.textByteSize;\n      }\n      if (this.activeInputType === \"file\") {\n        return this.fileByteSize;\n      }\n      return null;\n    }\n  },\n  methods: {\n    ...mapActions(\"input\", [\"initBinary\", \"clearBinary\"]),\n    async updateBinary() {\n      if (this.storeInMemory) {\n        if (this.inputFile) {\n          await this.initBinary();\n        }\n      } else {\n        this.clearBinary();\n      }\n    }\n  },\n  watch: {\n    activeInputType() {\n      bus.$emit(\"input-changed\");\n    },\n    async storeInMemory() {\n      await this.updateBinary();\n    },\n    async inputFile() {\n      if (this.activeInputTypeAutoSwitcher && this.activeInputType !== \"file\") {\n        this.activeInputType = \"file\";\n      } else {\n        bus.$emit(\"input-changed\");\n      }\n      await this.updateBinary();\n    },\n    inputText() {\n      if (this.activeInputTypeAutoSwitcher && this.activeInputType !== \"text\") {\n        this.activeInputType = \"text\";\n      } else {\n        bus.$emit(\"input-changed\");\n      }\n    },\n  },\n  components: {\n    FormattedNumber\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.input-switch-component {\n  > * {\n    padding: 0 2px;\n  }\n  > div {\n    padding-bottom: 6px;\n  }\n\n  .input-switch-checkbox {\n    opacity: 0;\n    transition: opacity 0.4s ease;\n    &:hover {\n      opacity: 1;\n      transition: opacity 0.25s ease;\n    }\n  }\n}\n\n.red {\n  color: var(--red);\n}\n</style>","<template lang=\"pug\">\ndiv.memory-consuming-component(\n    v-if=\"isSupported\"\n    :style=\"{width: percent + '%'}\"\n    :title=\"'Heap size: ' + formattedSize\")\n  div.visible(:class=\"{over100}\")\n  div.invisible\n</template>\n\n<script>\nimport * as Util from \"../util.js\";\n\nexport default {\n  name: \"MemoryConsuming\",\n  data() {\n    return {\n      memory: performance.memory,\n      intervalId: null,\n      over100: false\n    }\n  },\n  computed: {\n    jsHeapSizeLimit() {return this.memory.jsHeapSizeLimit},\n    totalJSHeapSize() {return this.memory.totalJSHeapSize},\n    usedJSHeapSize()  {return this.memory.usedJSHeapSize},\n    percent() {\n      const percent = this.totalJSHeapSize / (this.jsHeapSizeLimit / 100);\n      this.over100 = percent > 100;\n      return this.over100 ? 100 : percent;\n    },\n    formattedSize() {\n      return Util.bytesToSize(this.totalJSHeapSize);\n    },\n    isSupported() {\n      return this.memory;\n    }\n  },\n  mounted() {\n    if (!this.isSupported) {\n      return;\n    }\n    this.intervalId = setInterval(() => {\n      this.memory = performance.memory;\n    }, 1000);\n  },\n  beforeDestroy() {\n    if (this.intervalId) {\n      clearInterval(this.intervalId);\n    }\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.memory-consuming-component {\n  position: absolute;\n  left: 0;\n  top: 0;\n\n  > div {\n    width: 100%;\n  }\n  .visible {\n    background-color: #415aff;\n    height: 2px;\n    &.over100 {\n      background-color: #e30000;\n    }\n  }\n  .invisible {\n    height: 3px;\n  }\n}\n</style>","<template lang=\"pug\">\ndiv.file-settings-component\n  div.use-worker\n    label(title=\"Not works with stream hashing currently\")\n      input(type=\"checkbox\" v-model=\"useWorker\")\n      | Use web worker\n  div.store-in-memory\n    label\n      input(type=\"checkbox\" v-model=\"storeInMemory\")\n      | Store in memory\n      |\n      span(v-if=\"error\" :title=\"error.name + ': ' + error.message\" class=\"red\")\n        | (error...)\n      span(v-else-if=\"binaryLoading\")\n        | (loadings...)\n      span(title=\"loaded in\" v-else-if=\"loadingToMemoryTime && storeInMemory\")\n        | (\n        FormattedNumber(:number=\"loadingToMemoryTime\")\n        |\n        | ms)\n\n  div.stream-type\n    div(:style=\"{opacity: storeInMemory ? 0.5 : 1}\")\n      label\n        input(type=\"radio\" name=\"streamType\" value=\"FileReader\" v-model=\"streamType\")\n        | FileReader\n      label\n        input(type=\"radio\" name=\"streamType\" value=\"ReadableStream\" v-model=\"streamType\")\n        | ReadableStream\n\n    label(\n      title=\"Chunk size for progressive hashing, Megabytes\"\n      :style=\"{opacity: streamType === 'ReadableStream' && !storeInMemory ? 0.5 : 1}\")\n      | Chunk size, MB\n      input(\n        type=\"number\" min=\"0.1\" step=\"0.1\"\n        v-model=\"readerChunkSizeMB\"\n        :class=\"{invalid: readerChunkSize < 1}\"\n        :title=\"readerChunkSize > 0 ? '' : 'Value must be greater than or equal to 1 byte'\")\n\n  div.animation\n    span.checkbox\n      label\n        input(type=\"checkbox\" v-model=\"animation\")\n        | Animation,\n        |\n    span.fps(:style=\"{opacity: animation ? 1 : 0.5}\")\n      label\n        | FPS\n        input(type=\"number\" v-model=\"fps\")\n</template>\n\n<script>\nimport {mapState, mapGetters} from \"vuex\";\nimport FormattedNumber from \"./FormattedNumber.vue\";\n\nexport default {\n  name: \"FileSettings\",\n  computed: {\n    ...mapState(\"input\", {\n      loadingToMemoryTime: state => state.loadingToMemoryTime,\n      binaryLoading: state => state.binaryLoading,\n      error: state => state.error,\n    }),\n\n    ...mapGetters(\"file-settings\", [\"readerChunkSize\"]),\n    storeInMemory: {\n      get() { return this.$store.state[\"file-settings\"].storeInMemory; },\n      set(value) { this.$store.commit(\"file-settings/storeInMemory\", value); }\n    },\n    streamType: {\n      get() { return this.$store.state[\"file-settings\"].streamType; },\n      set(value) { this.$store.commit(\"file-settings/streamType\", value); }\n    },\n    readerChunkSizeMB: {\n      get() { return this.$store.state[\"file-settings\"].readerChunkSizeMB; },\n      set(value) { this.$store.commit(\"file-settings/readerChunkSizeMB\", value); }\n    },\n    animation: {\n      get() { return this.$store.state[\"file-settings\"].animation; },\n      set(value) { this.$store.commit(\"file-settings/animation\", value); }\n    },\n    fps: {\n      get() { return this.$store.state[\"file-settings\"].fps; },\n      set(value) { this.$store.commit(\"file-settings/fps\", value); }\n    },\n    useWorker: {\n      get() { return this.$store.state[\"file-settings\"].useWorker; },\n      set(value) { this.$store.commit(\"file-settings/useWorker\", value); }\n    }\n  },\n  watch: {\n    error() {\n      if (this.error) {\n        this.storeInMemory = false;\n      }\n    },\n  },\n  components: {\n    FormattedNumber\n  }\n}\n</script>\n\n<style lang=\"scss\" scoped>\n.file-settings-component {\n  &.inactive {\n    opacity: 0.5;\n  }\n\n  > * {\n    margin: 6px 2px;\n  }\n\n  input[type=\"number\"] {\n    max-width: 42px;\n    margin-left: 4px;\n    margin-top: 4px;\n\n    &.invalid {\n      border: 2px solid var(--red);\n      outline: none;\n      box-shadow: 0 0 1px 0 var(--red);\n    }\n  }\n}\n\n.red {\n  color: var(--red);\n}\n</style>","<template lang=\"pug\">\ndiv.main-container-component\n  MemoryConsuming\n  div.inputs\n    TextInput(:class=\"{'selected-input': activeInputType === 'text'}\")\n    FileInputDragNDrop(:class=\"{'selected-input': activeInputType === 'file'}\")\n    FileSettings(:class=\"{inactive: activeInputType !== 'file'}\")\n  InputSwitch\n  div.items\n    HasherItem(\n        v-for=\"(hasher, index) of hashers\"\n        :hasher=\"hasher\"\n        :key=\"hasher.id\"\n        :input=\"input\"\n        ref=\"items\")\n  div.interface\n    button(@click=\"computeAll\")\n      | Compute all\n</template>\n\n<script>\nimport HasherItem from \"./HasherItem.vue\";\nimport FileInputDragNDrop from \"./FileInputDragNDrop.vue\";\nimport TextInput from \"./TextInput.vue\";\nimport InputSwitch from \"./InputSwitch.vue\";\nimport FormattedNumber from \"./FormattedNumber.vue\";\nimport MemoryConsuming from \"./MemoryConsuming.vue\";\nimport FileSettings from \"./FileSettings.vue\";\n\nimport {mapState} from \"vuex\";\nimport {bus} from \"./bus.js\";\nimport * as Util from \"../util.js\";\n\nexport default {\n  name: \"MainContainer\",\n  data() {\n    return {\n      hashers: globalThis.MD5.list\n    }\n  },\n  computed: {\n    ...mapState(\"input\", {\n      inputText: state => state.text,\n      inputFile: state => state.file,\n      inputBinary: state => state.binary\n    }),\n\n    ...mapState(\"input-switch\", {\n      activeInputType: state => state.activeInputType\n    }),\n\n    input() {\n      if (this.activeInputType === \"file\") {\n        return this.inputBinary || this.inputFile;\n      } else if (this.activeInputType === \"text\") {\n        return this.inputText;\n      }\n    }\n  },\n  methods: {\n    async computeAll() {\n      bus.$emit(\"input-changed\"); // todo rename\n      for (const item of this.$refs.items) {\n        await item.compute();\n        await new Promise(resolve => Util.setImmediate(resolve));\n      }\n    },\n  },\n  components: {\n    TextInput,\n    FileInputDragNDrop,\n    FormattedNumber,\n    HasherItem,\n    InputSwitch,\n    MemoryConsuming,\n    FileSettings\n  }\n};\n</script>\n\n<style lang=\"scss\" scoped>\n.main-container-component::v-deep .formatted-number-component .number-trio-component > .padded {\n  letter-spacing: 3px;\n}\n\n.main-container-component {\n  padding: 10px;\n  box-sizing: border-box;\n\n  width: 100%;\n  height: 100%;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n\n  .inputs {\n    width: 100%;\n    max-width: calc(930px + 40px);\n    display: grid;\n    justify-content: center;\n    grid-template-columns: repeat(auto-fill, 280px);\n    grid-gap: 10px;\n    grid-auto-rows: 1fr;\n\n    .selected-input {\n      border: solid 1px var(--selected-input-border);\n      box-sizing: border-box;\n      box-shadow: 0 0 10px var(--selected-input-box-shadow);\n    }\n\n    .text-input-component {\n      @media all and (min-width: 580px) and (max-width: 894px) {\n        grid-column: 1 / 3;\n      }\n    }\n\n    @media all and (max-width: 579px) {\n      grid-template-columns: repeat(auto-fill, minmax(280px, 360px));\n    }\n  }\n\n  .input-switch-component {\n    padding: 6px;\n    margin-top: 12px;\n    margin-bottom: 12px;\n    background-color:    rgba(0,0,0,0.01);\n    box-shadow: 0 0 12px rgba(0,0,0,0.01);\n  }\n\n  .items {\n    width: 100%;\n    display: grid;\n    justify-content: center;\n    grid-template-columns: repeat(auto-fill, 280px);\n    grid-gap: 10px;\n  }\n\n  .interface {\n    margin-top: 12px;\n    display: flex;\n    justify-content: center;\n  }\n}\n</style>","import Vue from \"vue\";\nimport store from \"./store.js\";\n\nimport MainContainer from \"./components/MainContainer.vue\";\n\nnew Vue({\n    store,\n    render: createElement => createElement(MainContainer),\n}).$mount(\"#app\");\n"]}